<!DOCTYPE html>
<html lang="en">
<head>
    <title>Server API | ldapjs</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link rel="stylesheet" type="text/css" href="media/css/restdown.css">
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
</head>
<body>
<div id="header">
    <h1>Server API | ldapjs Documentation</h1>
</div>
<div id="sidebar">

<div>Sections</div>
<span>
<ul>
<li><div><a href="index.html">Home</a></div></li>
<li><div><a href="guide.html">Guide</a></div></li>
<li><div><a href="examples.html">Examples</a></div></li>
<li><div><a href="client.html">Client API</a></div></li>
<li><div><a href="server.html">Server API</a></div></li>
<li><div><a href="dn.html">DN API</a></div></li>
<li><div><a href="filters.html">Filters API</a></div></li>
<li><div><a href="errors.html">Error API</a></div></li>
</ul>
</span>

<div>Contents</div>
</span>
<ul>
  <li><div><a href="#create-a-server">Create a server</a></div>
  <ul>
    <li><div><a href="#properties-on-the-server-object">Properties on the server object</a></div></li>
    <li><div><a href="#listening-for-requests">Listening for requests</a></div></li>
  </ul></li>
  <li><div><a href="#routes">Routes</a></div>
  <ul>
    <li><div><a href="#common-request-elements">Common Request Elements</a></div></li>
    <li><div><a href="#common-response-elements">Common Response Elements</a></div></li>
    <li><div><a href="#errors">Errors</a></div></li>
  </ul></li>
  <li><div><a href="#bind">Bind</a></div>
  <ul>
    <li><div><a href="#bindrequest">BindRequest</a></div></li>
    <li><div><a href="#bindresponse">BindResponse</a></div></li>
  </ul></li>
  <li><div><a href="#add">Add</a></div>
  <ul>
    <li><div><a href="#addrequest">AddRequest</a></div></li>
    <li><div><a href="#addresponse">AddResponse</a></div></li>
  </ul></li>
  <li><div><a href="#search">Search</a></div>
  <ul>
    <li><div><a href="#searchrequest">SearchRequest</a></div></li>
    <li><div><a href="#searchresponse">SearchResponse</a></div></li>
  </ul></li>
  <li><div><a href="#modify">modify</a></div>
  <ul>
    <li><div><a href="#modifyrequest">ModifyRequest</a></div></li>
    <li><div><a href="#change">Change</a></div></li>
    <li><div><a href="#modifyresponse">ModifyResponse</a></div></li>
  </ul></li>
  <li><div><a href="#del">del</a></div>
  <ul>
    <li><div><a href="#deleterequest">DeleteRequest</a></div></li>
    <li><div><a href="#deleteresponse">DeleteResponse</a></div></li>
  </ul></li>
  <li><div><a href="#compare">compare</a></div>
  <ul>
    <li><div><a href="#comparerequest">CompareRequest</a></div></li>
    <li><div><a href="#compareresponse">CompareResponse</a></div></li>
  </ul></li>
  <li><div><a href="#modifydn">modifyDN</a></div>
  <ul>
    <li><div><a href="#modifydnrequest">ModifyDNRequest</a></div></li>
    <li><div><a href="#modifydnresponse">ModifyDNResponse</a></div></li>
  </ul></li>
  <li><div><a href="#exop">exop</a></div>
  <ul>
    <li><div><a href="#extendedrequest">ExtendedRequest</a></div></li>
    <li><div><a href="#extendedresponse">ExtendedResponse</a></div></li>
  </ul></li>
  <li><div><a href="#unbind">unbind</a></div></li>
</ul>

</div>
    <div id="content">

<h1>ldapjs Server API</h1>
<div class="intro">


<p>This document covers the ldapjs server API and assumes that you are familiar
with LDAP. If you're not, read the <a href="guide.html">guide</a> first.</p>


</div>
<h1 id="create-a-server">Create a server</h1>

<p>The code to create a new server looks like:</p>

<pre><code>var server = ldap.createServer();
</code></pre>

<p>The full list of options is:</p>

<table>
<tbody>
<tr><td>log</td><td>You can optionally pass in a bunyan instance the client will use to acquire a logger.</td></tr>
<tr><td>certificate</td><td>A PEM-encoded X.509 certificate; will cause this server to run in TLS mode.</td></tr>
<tr><td>key</td><td>A PEM-encoded private key that corresponds to <em>certificate</em> for SSL.</td></tr>
</tbody>
</table>

<h2 id="properties-on-the-server-object">Properties on the server object</h2>

<h3 id="maxconnections">maxConnections</h3>

<p>Set this property to reject connections when the server's connection count gets
high.</p>

<h3 id="connections-getter-only">connections (getter only)</h3>

<p>The number of concurrent connections on the server.</p>

<h3 id="url">url</h3>

<p>Returns the fully qualified URL this server is listening on. For example:
<code>ldaps://10.1.2.3:1636</code>.  If you haven't yet called <code>listen</code>, it will always
return <code>ldap://localhost:389</code>.</p>

<h3 id="event-close">Event: 'close'</h3>

<p><code>function() {}</code></p>

<p>Emitted when the server closes.</p>

<h2 id="listening-for-requests">Listening for requests</h2>

<p>The LDAP server API wraps up and mirrors the node.js <code>server.listen</code> family of
APIs.</p>

<p>After calling <code>listen</code>, the property <code>url</code> on the server object itself will be
available.</p>

<p>Example:</p>

<pre><code> server.listen(389, '127.0.0.1', function() {
   console.log(LDAP server listening at: ' + server.url);
 });
</code></pre>

<h3 id="port-and-host">Port and Host</h3>

<p><code>listen(port, [host], [callback])</code></p>

<p>Begin accepting connections on the specified port and host. If the host is
omitted, the server will accept connections directed to any IPv4 address
(INADDR_ANY).</p>

<p>This function is asynchronous. The last parameter callback will be called when
the server has been bound.</p>

<h3 id="unix-domain-socket">Unix Domain Socket</h3>

<p><code>listen(path, [callback])</code></p>

<p>Start a UNIX socket server listening for connections on the given path.</p>

<p>This function is asynchronous. The last parameter callback will be called when
the server has been bound.</p>

<h3 id="file-descriptor">File descriptor</h3>

<p><code>listenFD(fd)</code></p>

<p>Start a server listening for connections on the given file descriptor.</p>

<p>This file descriptor must have already had the <code>bind(2)</code> and <code>listen(2)</code> system
calls invoked on it. Additionally, it must be set non-blocking; try
<code>fcntl(fd, F_SETFL, O_NONBLOCK)</code>.</p>

<h1 id="routes">Routes</h1>

<p>The LDAP server API is meant to be the LDAP-equivalent of the express/restify
paradigm of programming.  Essentially every method is of the form
<code>OP(req, res, next)</code> where OP is one of bind, add, del, etc.  You can chain
handlers together by calling <code>next()</code> and ordering your functions in the
definition of the route.  For example:</p>

<pre><code>function authorize(req, res, next) {
  if (!req.connection.ldap.bindDN.equals('cn=root'))
    return next(new ldap.InsufficientAccessRightsError());

  return next();
}

server.search('o=example', authorize, function(req, res, next) { ... });
</code></pre>

<p>Note that ldapjs is also slightly different, since it's often going to be backed
to a DB-like entity, in that it also has an API where you can pass in a
'backend' object.  This is necessary if there are persistent connection pools,
caching, etc. that need to be placed in an object.</p>

<p>For example <a href="https://github.com/mcavage/node-ldapjs-riak">ldapjs-riak</a> is a
complete implementation of the LDAP protocol over
<a href="https://github.com/basho/riak">Riak</a>.  Getting an LDAP server up with riak
looks like:</p>

<pre><code>var ldap = require('ldapjs');
var ldapRiak = require('ldapjs-riak');

var server = ldap.createServer();
var backend = ldapRiak.createBackend({
  "host": "localhost",
  "port": 8098,
  "bucket": "example",
  "indexes": ["l", "cn"],
  "uniqueIndexes": ["uid"],
  "numConnections": 5
});

server.add("o=example",
           backend,
           backend.add());
...
</code></pre>

<p>The first parameter to an ldapjs route is always the point in the
tree to mount the handler chain at.  The second argument is <em>optionally</em> a
backend object.  After that you can pass in an arbitrary combination of
functions in the form <code>f(req, res, next)</code> or arrays of functions of the same
signature (ldapjs will unroll them).</p>

<p>Unlike HTTP, LDAP operations do not have a heterogeneous wire format, so each
operation requires specific methods/fields on the request/response
objects.  However, there is a <code>.use()</code> method availabe, similar to
that on express/connect, allowing you to chain up "middleware":</p>

<pre><code>server.use(function(req, res, next) {
  console.log('hello world');
  return next();
});
</code></pre>

<h2 id="common-request-elements">Common Request Elements</h2>

<p>All request objects have the <code>dn</code> getter on it, which is "context-sensitive"
and returns the point in the tree that the operation wants to operate on.  The
LDAP protocol itself sadly doesn't define operations this way, and has a unique
name for just about every op.  So, ldapjs calls it <code>dn</code>.  The DN object itself
is documented at <a href="dn.html">DN</a>.</p>

<p>All requests have an optional array of <code>Control</code> objects.  <code>Control</code> will have
the properties <code>type</code> (string), <code>criticality</code> (boolean), and optionally, a
string <code>value</code>.</p>

<p>All request objects will have a <code>connection</code> object, which is the <code>net.Socket</code>
associated to this request.  Off the <code>connection</code> object is an <code>ldap</code> object.
The most important property to pay attention to is the <code>bindDN</code> property
which will be an instance of an <code>ldap.DN</code> object.  This is what the client
authenticated as on this connection. If the client didn't bind, then a DN object
will be there defaulted to <code>cn=anonymous</code>.</p>

<p>Additionally, request will have a <code>logId</code> parameter you can use to uniquely
identify the request/connection pair in logs (includes the LDAP messageID).</p>

<h2 id="common-response-elements">Common Response Elements</h2>

<p>All response objects will have an <code>end</code> method on them.  By default, calling
<code>res.end()</code> with no arguments will return SUCCESS (0x00) to the client
(with the exception of <code>compare</code> which will return COMPARE_TRUE (0x06)).  You
can pass in a status code to the <code>end()</code> method to return an alternate status
code.</p>

<p>However, it's more common/easier to use the <code>return next(new LDAPError())</code>
pattern, since ldapjs will fill in the extra LDAPResult fields like matchedDN
and error message for you.</p>

<h2 id="errors">Errors</h2>

<p>ldapjs includes an exception hierarchy that directly corresponds to the RFC list
of error codes.  The complete list is documented in <a href="errors.html">errors</a>. But
the paradigm is something defined like CONSTRAINT_VIOLATION in the RFC would be
<code>ConstraintViolationError</code> in ldapjs.  Upon calling <code>next(new LDAPError())</code>,
ldapjs will <em>stop</em> calling your handler chain.  For example:</p>

<pre><code>server.search('o=example',
  function(req, res, next) { return next(); },
  function(req, res, next) { return next(new ldap.OperationsError()); },
  function(req, res, next) { res.end(); }
);
</code></pre>

<p>In the code snipped above, the third handler would never get invoked.</p>

<h1 id="bind">Bind</h1>

<p>Adds a mount in the tree to perform LDAP binds with. Example:</p>

<pre><code>server.bind('ou=people, o=example', function(req, res, next) {
  console.log('bind DN: ' + req.dn.toString());
  console.log('bind PW: ' + req.credentials);
  res.end();
});
</code></pre>

<h2 id="bindrequest">BindRequest</h2>

<p>BindRequest objects have the following properties:</p>

<h3 id="version">version</h3>

<p>The LDAP protocol version the client is requesting to run this connection on.
Note that ldapjs only supports LDAP version 3.</p>

<h3 id="name">name</h3>

<p>The DN the client is attempting to bind as (note this is the same as the <code>dn</code>
property).</p>

<h3 id="authentication">authentication</h3>

<p>The method of authentication.  Right now only <code>simple</code> is supported.</p>

<h3 id="credentials">credentials</h3>

<p>The credentials to go with the <code>name/authentication</code> pair.  For <code>simple</code>, this
will be the plain-text password.</p>

<h2 id="bindresponse">BindResponse</h2>

<p>No extra methods above an <code>LDAPResult</code> API call.</p>

<h1 id="add">Add</h1>

<p>Adds a mount in the tree to perform LDAP adds with.</p>

<pre><code>server.add('ou=people, o=example', function(req, res, next) {
  console.log('DN: ' + req.dn.toString());
  console.log('Entry attributes: ' + req.toObject().attributes);
  res.end();
});
</code></pre>

<h2 id="addrequest">AddRequest</h2>

<p>AddRequest objects have the following properties:</p>

<h3 id="entry">entry</h3>

<p>The DN the client is attempting to add (this is the same as the <code>dn</code>
property).</p>

<h3 id="attributes">attributes</h3>

<p>The set of attributes in this entry.  This will be an array of
<code>Attribute</code> objects (which have a type and an array of values).  This directly
maps to how the request came in off the wire.  It's likely you'll want to use
<code>toObject()</code> and iterate that way, since that will transform an AddRequest into
a standard JavaScript object.</p>

<h3 id="toobject">toObject()</h3>

<p>This operation will return a plain JavaScript object from the request that looks
like:</p>

<pre><code>{
  dn: 'cn=foo, o=example',  // string, not DN object
  attributes: {
    cn: ['foo'],
    sn: ['bar'],
    objectclass: ['person', 'top']
  }
}
</code></pre>

<h2 id="addresponse">AddResponse</h2>

<p>No extra methods above an <code>LDAPResult</code> API call.</p>

<h1 id="search">Search</h1>

<p>Adds a handler for the LDAP search operation.</p>

<pre><code>server.search('o=example', function(req, res, next) {
  console.log('base object: ' + req.dn.toString());
  console.log('scope: ' + req.scope);
  console.log('filter: ' + req.filter.toString());
  res.end();
});
</code></pre>

<h2 id="searchrequest">SearchRequest</h2>

<p>SearchRequest objects have the following properties:</p>

<h3 id="baseobject">baseObject</h3>

<p>The DN the client is attempting to start the search at (equivalent to <code>dn</code>).</p>

<h3 id="scope">scope</h3>

<p>(string) one of:</p>

<ul>
<li>base</li>
<li>one</li>
<li>sub</li>
</ul>

<h3 id="derefaliases">derefAliases</h3>

<p>An integer (defined in the LDAP protocol). Defaults to '0' (meaning
never deref).</p>

<h3 id="sizelimit">sizeLimit</h3>

<p>The number of entries to return. Defaults to '0' (unlimited). ldapjs doesn't
currently automatically enforce this, but probably will at some point.</p>

<h3 id="timelimit">timeLimit</h3>

<p>Maximum amount of time the server should take in sending search entries.
Defaults to '0' (unlimited).</p>

<h3 id="typesonly">typesOnly</h3>

<p>Whether to return only the names of attributes, and not the values.  Defaults to
'false'.  ldapjs will take care of this for you.</p>

<h3 id="filter">filter</h3>

<p>The <a href="filters.html">filter</a> object that the client requested.  Notably this has
a <code>matches()</code> method on it that you can leverage.  For an example of
introspecting a filter, take a look at the ldapjs-riak source.</p>

<h3 id="attributes-2">attributes</h3>

<p>An optional list of attributes to restrict the returned result sets to. ldapjs
will automatically handle this for you.</p>

<h2 id="searchresponse">SearchResponse</h2>

<h3 id="sendentry">send(entry)</h3>

<p>Allows you to send a <code>SearchEntry</code> object.  You do not need to
explicitly pass in a <code>SearchEntry</code> object, and can instead just send a plain
JavaScript object that matches the format used from <code>AddRequest.toObject()</code>.</p>

<pre><code>server.search('o=example', function(req, res, next) {
  var obj = {
    dn: 'o=example',
    attributes: {
      objectclass: ['top', 'organization'],
      o: ['example']
    }
  };

  if (req.filter.matches(obj))
    res.send(obj)

  res.end();
});
</code></pre>

<h1 id="modify">modify</h1>

<p>Allows you to handle an LDAP modify operation.</p>

<pre><code>server.modify('o=example', function(req, res, next) {
  console.log('DN: ' + req.dn.toString());
  console.log('changes:');
  req.changes.forEach(function(c) {
    console.log('  operation: ' + c.operation);
    console.log('  modification: ' + c.modification.toString());
  });
  res.end();
});
</code></pre>

<h2 id="modifyrequest">ModifyRequest</h2>

<p>ModifyRequest objects have the following properties:</p>

<h3 id="object">object</h3>

<p>The DN the client is attempting to update (this is the same as the <code>dn</code>
property).</p>

<h3 id="changes">changes</h3>

<p>An array of <code>Change</code> objects the client is attempting to perform. See below for
details on the <code>Change</code> object.</p>

<h2 id="change">Change</h2>

<p>The <code>Change</code> object will have the following properties:</p>

<h3 id="operation">operation</h3>

<p>A string, and will be one of: 'add', 'delete', or 'replace'.</p>

<h3 id="modification">modification</h3>

<p>Will be an <code>Attribute</code> object, which will have a 'type' (string) field, and
'vals', which will be an array of string values.</p>

<h2 id="modifyresponse">ModifyResponse</h2>

<p>No extra methods above an <code>LDAPResult</code> API call.</p>

<h1 id="del">del</h1>

<p>Allows you to handle an LDAP delete operation.</p>

<pre><code>server.del('o=example', function(req, res, next) {
  console.log('DN: ' + req.dn.toString());
  res.end();
});
</code></pre>

<h2 id="deleterequest">DeleteRequest</h2>

<h3 id="entry-2">entry</h3>

<p>The DN the client is attempting to delete (this is the same as the <code>dn</code>
property).</p>

<h2 id="deleteresponse">DeleteResponse</h2>

<p>No extra methods above an <code>LDAPResult</code> API call.</p>

<h1 id="compare">compare</h1>

<p>Allows you to handle an LDAP compare operation.</p>

<pre><code>server.compare('o=example', function(req, res, next) {
  console.log('DN: ' + req.dn.toString());
  console.log('attribute name: ' + req.attribute);
  console.log('attribute value: ' + req.value);
  res.end(req.value === 'foo');
});
</code></pre>

<h2 id="comparerequest">CompareRequest</h2>

<h3 id="entry-3">entry</h3>

<p>The DN the client is attempting to compare (this is the same as the <code>dn</code>
property).</p>

<h3 id="attribute">attribute</h3>

<p>The string name of the attribute to compare values of.</p>

<h3 id="value">value</h3>

<p>The string value of the attribute to compare.</p>

<h2 id="compareresponse">CompareResponse</h2>

<p>The <code>end()</code> method for compare takes a boolean, as opposed to a numeric code
(you can still pass in a numeric LDAP status code if you want). Beyond
that, there are no extra methods above an <code>LDAPResult</code> API call.</p>

<h1 id="modifydn">modifyDN</h1>

<p>Allows you to handle an LDAP modifyDN operation.</p>

<pre><code>server.modifyDN('o=example', function(req, res, next) {
  console.log('DN: ' + req.dn.toString());
  console.log('new RDN: ' + req.newRdn.toString());
  console.log('deleteOldRDN: ' + req.deleteOldRdn);
  console.log('new superior: ' +
    (req.newSuperior ? req.newSuperior.toString() : ''));

  res.end();
});
</code></pre>

<h2 id="modifydnrequest">ModifyDNRequest</h2>

<h3 id="entry-4">entry</h3>

<p>The DN the client is attempting to rename (this is the same as the <code>dn</code>
property).</p>

<h3 id="newrdn">newRdn</h3>

<p>The leaf RDN the client wants to rename this entry to. This will be a DN object.</p>

<h3 id="deleteoldrdn">deleteOldRdn</h3>

<p>Whether or not to delete the old RDN (i.e., rename vs copy). Defaults to 'true'.</p>

<h3 id="newsuperior">newSuperior</h3>

<p>Optional (DN).  If the modifyDN operation wishes to relocate the entry in the
tree, the <code>newSuperior</code> field will contain the new parent.</p>

<h2 id="modifydnresponse">ModifyDNResponse</h2>

<p>No extra methods above an <code>LDAPResult</code> API call.</p>

<h1 id="exop">exop</h1>

<p>Allows you to handle an LDAP extended operation. Extended operations are pretty
much arbitrary extensions, by definition.  Typically the extended 'name' is an
OID, but ldapjs makes no such restrictions; it just needs to be a string.
Unlike the other operations, extended operations don't map to any location in
the tree, so routing here will be exact match, as opposed to subtree.</p>

<pre><code>// LDAP whoami
server.exop('1.3.6.1.4.1.4203.1.11.3', function(req, res, next) {
  console.log('name: ' + req.name);
  console.log('value: ' + req.value);
  res.value = 'u:xxyyz@EXAMPLE.NET';
  res.end();
  return next();
});
</code></pre>

<h2 id="extendedrequest">ExtendedRequest</h2>

<h3 id="name-2">name</h3>

<p>Will always be a match to the route-defined name.  Clients must include this
in their requests.</p>

<h3 id="value-2">value</h3>

<p>Optional string. The arbitrary blob the client sends for this extended
operation.</p>

<h2 id="extendedresponse">ExtendedResponse</h2>

<h3 id="name-3">name</h3>

<p>The name of the extended operation. ldapjs will automatically set this.</p>

<h3 id="value-3">value</h3>

<p>The arbitrary (string) value to send back as part of the response.</p>

<h1 id="unbind">unbind</h1>

<p>ldapjs by default provides an unbind handler that just disconnects the client
and cleans up any internals (in ldapjs core).  You can override this handler
if you need to clean up any items in your backend, or perform any other cleanup
tasks you need to.</p>

<pre><code>server.unbind(function(req, res, next) {
  res.end();
});
</code></pre>

<p>Note that the LDAP unbind operation actually doesn't send any response (by
definition in the RFC), so the UnbindResponse is really just a stub that
ultimately calls <code>net.Socket.end()</code> for you. There are no properties available
on either the request or response objects, except, of course, for <code>end()</code> on the
response.</p>

    </div> <!-- #content -->
<script type="text/javascript" charset="utf-8">
$(function() {
    var headerHeight = $("#header").height();
    var offsets = [];
    var current = -1;

    function endpoint(scrollDistance) {
        if (scrollDistance < offsets[0]) {
            return -1;
        } else {
            for (var id = offsets.length; id > 0; id--) {
                if (scrollDistance > offsets[id - 1]) {
                    return id - 1;
                    break;
                }
            }
        }
    }

    $("h2").each(function(i) {
        offsets.push($(this).offset().top - headerHeight)
    });

    $("#content").append('<h2 class="fixed" style="display: none"><span>&nbsp;</span></h2>');
    var fixed_h2 = $("h2.fixed");
    var fixed_span = $("h2.fixed span");

    $("#content").scroll(function() {
        var scrollDistance = $("#content").attr('scrollTop');
        var now = endpoint(scrollDistance);

        if (now !== current) {
            $("#sidebar li").removeClass("current");
            current = now;
            if (current < 0) {
                fixed_h2.hide();
            } else if (current >= 0) {
                var heading = $($("h2 span")[current]).text();
                $("#sidebar a[href|=#" + heading.replace(' ', '-') + "]").parent().addClass("current");
                fixed_span.text(heading);
                fixed_h2.show();
            }
        }
    });
});
</script>

</body>
</html>
